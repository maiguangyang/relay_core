/* Code generated by cmd/cgo; DO NOT EDIT. */

/* package github.com/maiguangyang/relay_core */


#line 1 "cgo-builtin-export-prolog"

#include <stddef.h>

#ifndef GO_CGO_EXPORT_PROLOGUE_H
#define GO_CGO_EXPORT_PROLOGUE_H

#ifndef GO_CGO_GOSTRING_TYPEDEF
typedef struct { const char *p; ptrdiff_t n; } _GoString_;
#endif

#endif

/* Start of preamble from import "C" comments.  */


#line 11 "keepalive_codec_ffi.go"

#include <stdlib.h>
#include <stdint.h>
#include <pthread.h>
#include <unistd.h>

// Mutex for thread-safe ping callback access
static pthread_mutex_t pingCallbackMutex = PTHREAD_MUTEX_INITIALIZER;

// Ping 回调函数类型
typedef void (*PingCallback)(const char* peerID);

// 存储 ping 回调
static PingCallback pingCallback = NULL;

static void setPingCallback(PingCallback cb) {
    pthread_mutex_lock(&pingCallbackMutex);
    pingCallback = cb;
    pthread_mutex_unlock(&pingCallbackMutex);
}

static void invalidatePingCallback() {
    pthread_mutex_lock(&pingCallbackMutex);
    pingCallback = NULL;
    pthread_mutex_unlock(&pingCallbackMutex);
    usleep(50000); // 50ms grace period
}

static void callPingCallback(const char* peerID) {
    pthread_mutex_lock(&pingCallbackMutex);
    if (pingCallback != NULL) {
        pingCallback(peerID);
    }
    pthread_mutex_unlock(&pingCallbackMutex);
}

#line 1 "cgo-generated-wrapper"

#line 12 "livekit_bridge_ffi.go"

#include <stdlib.h>

#line 1 "cgo-generated-wrapper"

#line 15 "main.go"

#include <stdlib.h>
#include <stdint.h>
#include <pthread.h>
#include <unistd.h>

// Generation counter for detecting stale callbacks
// Incremented each time callbacks are set or cleared
static volatile int64_t callbackGeneration = 0;

// Mutex for thread-safe callback access
static pthread_mutex_t callbackMutex = PTHREAD_MUTEX_INITIALIZER;

// Callback function types for events
typedef void (*EventCallback)(int eventType, const char* roomId, const char* peerId, const char* data);
typedef void (*LogCallback)(int level, const char* message);

// Store the callbacks
static EventCallback eventCallback = NULL;
static LogCallback logCallback = NULL;

// Get current generation (for Go code to check before/after)
static int64_t getCallbackGeneration() {
    return callbackGeneration;
}

// Setter functions - increment generation on each change
static void setEventCallback(EventCallback cb) {
    pthread_mutex_lock(&callbackMutex);
    eventCallback = cb;
    callbackGeneration++;
    pthread_mutex_unlock(&callbackMutex);
}

static void setLogCallback(LogCallback cb) {
    pthread_mutex_lock(&callbackMutex);
    logCallback = cb;
    callbackGeneration++;
    pthread_mutex_unlock(&callbackMutex);
}

// Invalidate all callbacks and wait for grace period
static void invalidateAllCallbacks() {
    pthread_mutex_lock(&callbackMutex);
    eventCallback = NULL;
    logCallback = NULL;
    callbackGeneration++;
    pthread_mutex_unlock(&callbackMutex);

    // Grace period: allow any in-flight operations to detect the invalidation
    usleep(50000); // 50ms
}

// Caller functions - check if callback is still valid
static void callEventCallback(int eventType, const char* roomId, const char* peerId, const char* data) {
    pthread_mutex_lock(&callbackMutex);
    if (eventCallback != NULL) {
        eventCallback(eventType, roomId, peerId, data);
    }
    pthread_mutex_unlock(&callbackMutex);
}

static void callLogCallback(int level, const char* message) {
    pthread_mutex_lock(&callbackMutex);
    if (logCallback != NULL) {
        logCallback(level, message);
    }
    pthread_mutex_unlock(&callbackMutex);
}

#line 1 "cgo-generated-wrapper"

#line 12 "proxy_mode_ffi.go"

#include <stdlib.h>
#include <stdint.h>

#line 1 "cgo-generated-wrapper"

#line 12 "relay_room_ffi.go"

#include <stdlib.h>
#include <stdint.h>

#line 1 "cgo-generated-wrapper"

#line 11 "stats_probe_ffi.go"

#include <stdlib.h>
#include <stdint.h>

#line 1 "cgo-generated-wrapper"


/* End of preamble from import "C" comments.  */


/* Start of boilerplate cgo prologue.  */
#line 1 "cgo-gcc-export-header-prolog"

#ifndef GO_CGO_PROLOGUE_H
#define GO_CGO_PROLOGUE_H

typedef signed char GoInt8;
typedef unsigned char GoUint8;
typedef short GoInt16;
typedef unsigned short GoUint16;
typedef int GoInt32;
typedef unsigned int GoUint32;
typedef long long GoInt64;
typedef unsigned long long GoUint64;
typedef GoInt64 GoInt;
typedef GoUint64 GoUint;
typedef size_t GoUintptr;
typedef float GoFloat32;
typedef double GoFloat64;
#ifdef _MSC_VER
#include <complex.h>
typedef _Fcomplex GoComplex64;
typedef _Dcomplex GoComplex128;
#else
typedef float _Complex GoComplex64;
typedef double _Complex GoComplex128;
#endif

/*
  static assertion to make sure the file is being used on architecture
  at least with matching size of GoInt.
*/
typedef char _check_for_64_bit_pointer_matching_GoInt[sizeof(void*)==64/8 ? 1:-1];

#ifndef GO_CGO_GOSTRING_TYPEDEF
typedef _GoString_ GoString;
#endif
typedef void *GoMap;
typedef void *GoChan;
typedef struct { void *t; void *v; } GoInterface;
typedef struct { void *data; GoInt len; GoInt cap; } GoSlice;

#endif

/* End of boilerplate cgo prologue.  */

#ifdef __cplusplus
extern "C" {
#endif


// KeepaliveCreate 创建心跳管理器
// intervalMs: 心跳间隔（毫秒）
// timeoutMs: 超时时间（毫秒）
//
extern int KeepaliveCreate(char* roomID, int intervalMs, int timeoutMs);

// KeepaliveDestroy 销毁心跳管理器
//
extern int KeepaliveDestroy(char* roomID);

// KeepaliveStart 启动心跳检测
//
extern int KeepaliveStart(char* roomID);

// KeepaliveStop 停止心跳检测
//
extern int KeepaliveStop(char* roomID);

// KeepaliveAddPeer 添加需要监控的 Peer
//
extern int KeepaliveAddPeer(char* roomID, char* peerID);

// KeepaliveRemovePeer 移除 Peer
//
extern int KeepaliveRemovePeer(char* roomID, char* peerID);

// KeepaliveHandlePong 处理收到的 Pong
// 当 Dart 层收到对方的 pong 响应时调用此函数
//
extern int KeepaliveHandlePong(char* roomID, char* peerID);

// KeepaliveGetPeerStatus 获取 Peer 状态
// 返回: 0=Unknown, 1=Online, 2=Slow, 3=Offline
//
extern int KeepaliveGetPeerStatus(char* roomID, char* peerID);

// KeepaliveGetPeerRTT 获取 Peer 的 RTT（毫秒）
//
extern int64_t KeepaliveGetPeerRTT(char* roomID, char* peerID);

// KeepaliveGetPeerInfo 获取 Peer 心跳详细信息
//
extern char* KeepaliveGetPeerInfo(char* roomID, char* peerID);

// KeepaliveGetAllPeerInfo 获取所有 Peer 心跳信息
//
extern char* KeepaliveGetAllPeerInfo(char* roomID);

// SetPingCallback 设置 Ping 回调
// 当需要发送 ping 时会调用此回调
//
extern void SetPingCallback(PingCallback callback);

// CodecGetSupportedVideo 获取支持的视频编解码器列表
//
extern char* CodecGetSupportedVideo();

// CodecGetSupportedAudio 获取支持的音频编解码器列表
//
extern char* CodecGetSupportedAudio();

// CodecParseType 解析 MimeType 获取编解码器类型
//
extern char* CodecParseType(char* mimeType);

// CodecIsVideo 判断是否是视频编解码器
//
extern int CodecIsVideo(char* codecType);

// CodecIsAudio 判断是否是音频编解码器
//
extern int CodecIsAudio(char* codecType);

// LiveKitBridgeCreate 创建 LiveKit 桥接器
// 返回: 0 成功, -1 失败
//
extern int LiveKitBridgeCreate(char* roomID);

// LiveKitBridgeConnect 连接到 LiveKit 房间 (异步)
// 立即返回，连接在后台进行
// 返回: 0 成功启动, -1 失败
//
extern int LiveKitBridgeConnect(char* roomID, char* url, char* token);

// LiveKitBridgeDisconnect 断开 LiveKit 连接
// 返回: 0 成功, -1 失败
//
extern int LiveKitBridgeDisconnect(char* roomID);

// LiveKitBridgeDestroy 销毁 LiveKit 桥接器
// 返回: 0 成功
//
extern int LiveKitBridgeDestroy(char* roomID);

// LiveKitBridgeGetStatus 获取桥接器状态
// 返回: JSON 字符串，需要调用 FreeString 释放
//
extern char* LiveKitBridgeGetStatus(char* roomID);

// LiveKitBridgeIsConnected 检查是否已连接
// 返回: 1 已连接, 0 未连接
//
extern int LiveKitBridgeIsConnected(char* roomID);
extern int ElectionEnable(int64_t relayID, char* roomID);
extern int ElectionDisable(int64_t relayID, char* roomID);
extern int ElectionUpdateCandidate(int64_t relayID, char* roomID, char* peerID, int64_t bandwidth, int64_t latency, double packetLoss);
extern char* ElectionTrigger(int64_t relayID, char* roomID);
extern char* ElectionGetProxy(int64_t relayID, char* roomID);
extern void SetEventCallback(EventCallback callback);
extern void SetLogCallback(LogCallback callback);
extern void SetLogLevel(int level);
extern void FreeString(char* s);
extern void CleanupAll();
extern char* GetVersion();

// SourceSwitcherCreate 创建源切换器
//
extern int SourceSwitcherCreate(char* roomID);

// SourceSwitcherDestroy 销毁源切换器
//
extern int SourceSwitcherDestroy(char* roomID);

// SourceSwitcherInjectSFU 注入来自 SFU 的 RTP 包
// isVideo: 1 = video, 0 = audio
// data: RTP 原始数据
// dataLen: 数据长度
//
extern int SourceSwitcherInjectSFU(char* roomID, int isVideo, void* data, int dataLen);

// SourceSwitcherInjectLocal 注入来自本地分享者的 RTP 包
//
extern int SourceSwitcherInjectLocal(char* roomID, int isVideo, void* data, int dataLen);

// SourceSwitcherStartLocalShare 开始本地分享
//
extern int SourceSwitcherStartLocalShare(char* roomID, char* sharerID);

// SourceSwitcherStopLocalShare 停止本地分享
//
extern int SourceSwitcherStopLocalShare(char* roomID);

// SourceSwitcherGetStatus 获取源切换器状态
//
extern char* SourceSwitcherGetStatus(char* roomID);

// SourceSwitcherIsLocalSharing 检查是否正在本地分享
//
extern int SourceSwitcherIsLocalSharing(char* roomID);

// ElectionUpdateDeviceInfo 更新设备信息
// deviceType: 0=Unknown, 1=PC, 2=Pad, 3=Mobile, 4=TV
// connectionType: 0=Unknown, 1=Ethernet, 2=WiFi, 3=Cellular
// powerState: 0=Unknown, 1=PluggedIn, 2=Battery, 3=LowBattery
//
extern int ElectionUpdateDeviceInfo(int64_t relayID, char* roomID, char* peerID, int deviceType, int connectionType, int powerState);

// ElectionUpdateNetworkMetrics 更新网络指标
//
extern int ElectionUpdateNetworkMetrics(int64_t relayID, char* roomID, char* peerID, int64_t bandwidth, int64_t latency, double packetLoss);

// ElectionGetCandidates 获取所有候选者列表
//
extern char* ElectionGetCandidates(int64_t relayID, char* roomID);

// ProxyModeInit 初始化代理模式（创建 SourceSwitcher + 启用选举）
//
extern int ProxyModeInit(int64_t relayID, char* roomID);

// ProxyModeCleanup 清理代理模式
//
extern int ProxyModeCleanup(int64_t relayID, char* roomID);

// ProxyModeGetStatus 获取代理模式综合状态
//
extern char* ProxyModeGetStatus(int64_t relayID, char* roomID);

// FailoverEnable 启用自动故障切换
// localPeerID: 本机 Peer ID
//
extern int FailoverEnable(char* roomID, char* localPeerID);

// FailoverDisable 禁用自动故障切换
//
extern int FailoverDisable(char* roomID);

// FailoverSetCurrentRelay 设置当前 Relay
//
extern int FailoverSetCurrentRelay(char* roomID, char* relayID, uint64_t epoch);

// FailoverUpdateLocalScore 更新本机分数
//
extern int FailoverUpdateLocalScore(char* roomID, double score);

// FailoverReceiveClaim 接收其他节点的 Relay 声明
// epoch: 选举纪元号
// score: 声明者的分数（用于同 epoch 冲突解决）
//
extern int FailoverReceiveClaim(char* roomID, char* peerID, uint64_t epoch, double score);

// FailoverGetState 获取故障切换状态
//
extern char* FailoverGetState(char* roomID);

// CoordinatorEnable 一键启用自动代理模式
// 自动管理：心跳、选举、故障切换、Relay 接管
// 用户无需关心内部细节，完全自动
//
extern int CoordinatorEnable(char* roomID, char* localPeerID);

// CoordinatorDisable 禁用自动代理模式
//
extern int CoordinatorDisable(char* roomID);

// CoordinatorAddPeer 添加 Peer 到自动管理
//
extern int CoordinatorAddPeer(char* roomID, char* peerID, int deviceType, int connectionType, int powerState);

// CoordinatorRemovePeer 移除 Peer
//
extern int CoordinatorRemovePeer(char* roomID, char* peerID);

// CoordinatorHandlePong 处理 Pong（心跳响应）
//
extern int CoordinatorHandlePong(char* roomID, char* peerID);

// CoordinatorSetRelay 设置当前 Relay（收到外部通知时）
//
extern int CoordinatorSetRelay(char* roomID, char* relayID, uint64_t epoch);

// CoordinatorReceiveClaim 接收 Relay 声明
// epoch: 选举纪元号
// score: 声明者分数（用于同 epoch 冲突解决）
//
extern int CoordinatorReceiveClaim(char* roomID, char* peerID, uint64_t epoch, double score);

// CoordinatorUpdateLocalDevice 更新本机设备信息
//
extern int CoordinatorUpdateLocalDevice(char* roomID, int deviceType, int connectionType, int powerState);

// CoordinatorInjectSFU 注入 SFU RTP 包
//
extern int CoordinatorInjectSFU(char* roomID, int isVideo, void* data, int dataLen);

// CoordinatorInjectLocal 注入本地分享 RTP 包
//
extern int CoordinatorInjectLocal(char* roomID, int isVideo, void* data, int dataLen);

// CoordinatorStartLocalShare 开始本地分享
//
extern int CoordinatorStartLocalShare(char* roomID, char* sharerID);

// CoordinatorStopLocalShare 停止本地分享
//
extern int CoordinatorStopLocalShare(char* roomID);

// CoordinatorGetStatus 获取协调器状态
//
extern char* CoordinatorGetStatus(char* roomID);

// CoordinatorIsRelay 检查本机是否是 Relay
//
extern int CoordinatorIsRelay(char* roomID);

// RelayRoomCreate 创建代理房间
// iceServersJSON: ICE 服务器配置 JSON
//
extern int RelayRoomCreate(char* roomID, char* iceServersJSON);

// RelayRoomDestroy 销毁代理房间
//
extern int RelayRoomDestroy(char* roomID);

// RelayRoomBecomeRelay 成为 Relay 节点
//
extern int RelayRoomBecomeRelay(char* roomID, char* peerID);

// RelayRoomIsRelay 检查是否是 Relay 节点
//
extern int RelayRoomIsRelay(char* roomID);

// RelayRoomAddSubscriber 添加订阅者
// 使用远端 Offer 创建 P2P 连接，返回 Answer SDP
//
extern char* RelayRoomAddSubscriber(char* roomID, char* peerID, char* offerSDP);

// RelayRoomRemoveSubscriber 移除订阅者
//
extern int RelayRoomRemoveSubscriber(char* roomID, char* peerID);

// RelayRoomGetSubscribers 获取订阅者列表
//
extern char* RelayRoomGetSubscribers(char* roomID);

// RelayRoomGetSubscriberCount 获取订阅者数量
//
extern int RelayRoomGetSubscriberCount(char* roomID);

// RelayRoomAddICECandidate 添加 ICE 候选
//
extern int RelayRoomAddICECandidate(char* roomID, char* peerID, char* candidateJSON);

// RelayRoomTriggerRenegotiation 触发重协商
// 为所有已连接的订阅者生成新的 Offer
// 返回 JSON: {"peerID1": "offer1", "peerID2": "offer2", ...}
//
extern char* RelayRoomTriggerRenegotiation(char* roomID);

// RelayRoomCreateOffer 为指定订阅者创建 Offer
//
extern char* RelayRoomCreateOffer(char* roomID, char* peerID);

// RelayRoomHandleAnswer 处理订阅者的 Answer（重协商响应）
//
extern int RelayRoomHandleAnswer(char* roomID, char* peerID, char* answerSDP);

// RelayRoomGetStatus 获取房间状态
//
extern char* RelayRoomGetStatus(char* roomID);

// RelayRoomInjectSFU 注入 SFU RTP 包（通过 RelayRoom）
//
extern int RelayRoomInjectSFU(char* roomID, int isVideo, void* data, int dataLen);

// RelayRoomInjectLocal 注入本地分享 RTP 包（通过 RelayRoom）
//
extern int RelayRoomInjectLocal(char* roomID, int isVideo, void* data, int dataLen);

// RelayRoomStartLocalShare 开始本地分享
//
extern int RelayRoomStartLocalShare(char* roomID, char* sharerID);

// RelayRoomStopLocalShare 停止本地分享
//
extern int RelayRoomStopLocalShare(char* roomID);

// BufferPoolGetStats 获取全局缓冲池统计
//
extern char* BufferPoolGetStats();

// BufferPoolResetStats 重置缓冲池统计
//
extern void BufferPoolResetStats();

// StatsCreate 创建房间统计
//
extern int StatsCreate(char* roomID);

// StatsDestroy 销毁房间统计
//
extern int StatsDestroy(char* roomID);

// StatsAddBytesIn 添加接收字节数
//
extern int StatsAddBytesIn(char* roomID, char* peerID, uint64_t bytes);

// StatsAddBytesOut 添加发送字节数
//
extern int StatsAddBytesOut(char* roomID, char* peerID, uint64_t bytes);

// StatsAddPacketLost 添加丢包数
//
extern int StatsAddPacketLost(char* roomID);

// StatsCalculateBitrate 计算码率（每秒调用一次）
//
extern int StatsCalculateBitrate(char* roomID);

// StatsGetSnapshot 获取统计快照
//
extern char* StatsGetSnapshot(char* roomID);

// StatsGetTraffic 获取总体流量统计
//
extern char* StatsGetTraffic(char* roomID);

// StatsGetBitrateIn 获取入站码率 (bps)
//
extern double StatsGetBitrateIn(char* roomID);

// StatsGetBitrateOut 获取出站码率 (bps)
//
extern double StatsGetBitrateOut(char* roomID);

// StatsGetLossRate 获取丢包率
//
extern double StatsGetLossRate(char* roomID);

// NetworkProbeCreate 创建网络探测管理器
//
extern int NetworkProbeCreate(char* roomID);

// NetworkProbeDestroy 销毁网络探测管理器
//
extern int NetworkProbeDestroy(char* roomID);

// NetworkProbeGetMetrics 获取指定 Peer 的网络指标
//
extern char* NetworkProbeGetMetrics(char* roomID, char* peerID);

// NetworkProbeGetAllMetrics 获取所有 Peer 的网络指标
//
extern char* NetworkProbeGetAllMetrics(char* roomID);

// JitterBufferCreate 创建抖动缓冲
// enabled: 是否启用
// targetDelayMs: 目标延迟（毫秒）
//
extern int JitterBufferCreate(char* key, int enabled, int targetDelayMs);

// JitterBufferDestroy 销毁抖动缓冲
//
extern int JitterBufferDestroy(char* key);

// JitterBufferEnable 启用/禁用抖动缓冲
//
extern int JitterBufferEnable(char* key, int enabled);

// JitterBufferSetDelay 设置目标延迟
//
extern int JitterBufferSetDelay(char* key, int delayMs);

// JitterBufferFlush 清空缓冲区
//
extern int JitterBufferFlush(char* key);

// JitterBufferGetStats 获取抖动缓冲统计
//
extern char* JitterBufferGetStats(char* key);

// JitterBufferIsEnabled 检查是否启用
//
extern int JitterBufferIsEnabled(char* key);

#ifdef __cplusplus
}
#endif
